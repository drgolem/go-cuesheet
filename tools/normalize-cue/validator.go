package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// checkDirectory validates all CUE files in a directory and outputs cleanup script
func checkDirectory(dir string, recursive bool) {
	var cueFiles []string

	if recursive {
		// Walk directory recursively
		err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && strings.ToLower(filepath.Ext(path)) == ".cue" {
				cueFiles = append(cueFiles, path)
			}
			return nil
		})
		if err != nil {
			fmt.Fprintf(os.Stderr, "# Error walking directory: %v\n", err)
			os.Exit(1)
		}
	} else {
		// Only process files in the specified directory (non-recursive)
		entries, err := os.ReadDir(dir)
		if err != nil {
			fmt.Fprintf(os.Stderr, "# Error reading directory: %v\n", err)
			os.Exit(1)
		}
		for _, entry := range entries {
			if !entry.IsDir() && strings.ToLower(filepath.Ext(entry.Name())) == ".cue" {
				cueFiles = append(cueFiles, filepath.Join(dir, entry.Name()))
			}
		}
	}

	if len(cueFiles) == 0 {
		fmt.Fprintf(os.Stderr, "# No CUE files found in %s\n", dir)
		return
	}

	fmt.Printf("#!/bin/bash\n")
	fmt.Printf("# CUE file cleanup script - generated by normalize-cue\n")
	fmt.Printf("# Found %d CUE file(s) to validate\n", len(cueFiles))
	fmt.Printf("# Review this script before executing!\n\n")

	badFiles := 0
	for _, cueFile := range cueFiles {
		issues := validateCueFile(cueFile)
		if len(issues) > 0 {
			badFiles++
			fmt.Printf("# [MALFORMED] %s\n", cueFile)
			for _, issue := range issues {
				fmt.Printf("#   - %s\n", issue)
			}
			fmt.Printf("rm \"%s\"\n\n", cueFile)
		}
	}

	if badFiles == 0 {
		fmt.Printf("# All CUE files are valid - no cleanup needed!\n")
	} else {
		fmt.Fprintf(os.Stderr, "# Found %d malformed file(s) out of %d total\n", badFiles, len(cueFiles))
	}
}

// validateCueFile validates a CUE file and returns a list of issues
func validateCueFile(cuePath string) []string {
	var issues []string

	// Check if file exists and get size
	info, err := os.Stat(cuePath)
	if err != nil {
		issues = append(issues, fmt.Sprintf("Cannot read file: %v", err))
		return issues
	}

	// Check for empty file
	if info.Size() == 0 {
		issues = append(issues, "File is empty (0 bytes)")
		return issues
	}

	// Try to read the file
	lines, err := readCueFile(cuePath)
	if err != nil {
		issues = append(issues, fmt.Sprintf("Cannot parse file: %v", err))
		return issues
	}

	// Check if file has only whitespace
	hasContent := false
	for _, line := range lines {
		if strings.TrimSpace(line) != "" {
			hasContent = true
			break
		}
	}
	if !hasContent {
		issues = append(issues, "File contains only whitespace")
		return issues
	}

	// Check for required fields
	hasFile := false
	hasTrack := false
	hasIndex := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		upper := strings.ToUpper(trimmed)

		if strings.HasPrefix(upper, "FILE ") {
			hasFile = true
		}
		if strings.HasPrefix(upper, "TRACK ") {
			hasTrack = true
		}
		if strings.HasPrefix(upper, "INDEX ") {
			hasIndex = true
		}
	}

	if !hasFile {
		issues = append(issues, "Missing FILE entry")
	}
	if !hasTrack {
		issues = append(issues, "Missing TRACK entry")
	}
	if !hasIndex {
		issues = append(issues, "Missing INDEX entry")
	}

	// If basic structure is present, check if audio files exist
	if hasFile {
		cueDir := filepath.Dir(cuePath)
		audioFiles, err := scanAudioFiles(cueDir)
		if err == nil && len(audioFiles) == 0 {
			issues = append(issues, "No audio files found in directory")
		}

		// Extract FILE entries and check if any match actual files
		if len(audioFiles) > 0 {
			fileLineRegex := regexp.MustCompile(`^\s*FILE\s+"?([^"]+?)"?\s+(?:WAVE|MP3|AIFF|BINARY|MOTOROLA)?\s*$`)
			foundMatch := false

			for _, line := range lines {
				matches := fileLineRegex.FindStringSubmatch(line)
				if matches != nil {
					filePath := matches[1]
					// Extract just the filename
					normalizedPath := strings.ReplaceAll(filePath, "\\", "/")
					fileName := filepath.Base(normalizedPath)

					// Check if this file exists in the directory
					for _, audioFile := range audioFiles {
						if strings.EqualFold(fileName, audioFile) ||
							strings.EqualFold(strings.TrimSuffix(fileName, filepath.Ext(fileName)),
								strings.TrimSuffix(audioFile, filepath.Ext(audioFile))) {
							foundMatch = true
							break
						}
					}
					if foundMatch {
						break
					}
				}
			}

			if !foundMatch {
				issues = append(issues, "No FILE entries match actual audio files in directory")
			}
		}
	}

	return issues
}
